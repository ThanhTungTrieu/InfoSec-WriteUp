# Phân tích CVE-2023-25157 - GeoServer SQL Injection

## Giới thiệu GeoServer
GeoServer là một máy chủ mã nguồn mở với mục đích kết nối những thông tin địa lý có sẵn tới các WebGIS (trang web địa lý) sử dụng chuẩn mở.

GeoServer có thể đọc được nhiều định dạng dữ liệu, bao gồm PostGIS, Oracle
Spatital, ArcSDE, DB2, MySQL, Shapefile, GeoTIFF, GTOPO30 và nhiều loại
khác. Bên cạnh đó, GeoServer còn có thể chỉnh sửa dữ liệu nhờ những thành phần xử lý của chuẩn Web Feature Server.

GeoServer chủ yếu được xây dựng trên Spring Framework. Tuy nhiên, GeoServer cũng sử dụng một số thư viện và framework khác, bao gồm:

- **GeoTools**: Một thư viện Java mã nguồn mở cung cấp các công cụ cho dữ liệu không gian địa lý. GeoServer sử dụng GeoTools cho nhiều chức năng cốt lõi của nó, chẳng hạn như đọc, ghi và chuyển đổi dữ liệu.
- **Hibernate Validator**: Dùng để validate Java bean.
- **Apache Wicket**: Được sử dụng cho giao diện quản trị web. Đó là một web Framework dựa trên các thành phần tương tự như JavaServer Faces (JSF) và Tapestry.
- **Log4J**:  Dùng để hỗ trợ log.

## Giới thiệu lỗ hổng CVE-2023-25157
Với CVSS 9.8 (Critical), đây được đánh giá là một lỗ hổng ở mức nghiêm trọng, việc khai thác thành công có thể dẫn đến rò rỉ, sửa đổi dữ liệu, hay dẫn đến tấn công từ chối dịch vụ .CVE-2023-25157 liên quan đến lỗ hổng SQL Injection tồn tại trong OGC (Open Geospatial Consortium) query function mà GeoServer sử dụng. GeoServer hỗ trợ sử dụng Filter Expression Language OGC và Common Query Language OGC (CQL) như một phần của các giao thức Web Feature Service (WFS), Web Map Service (WMS) và Web Coverage Service (WCS). Dưới đây là chi tiết về các lỗ hổng được tìm thấy trong GeoServer:

- `PropertyIsLike` filter: Lỗ hổng này xuất hiện khi PropertyIsLike filter được sử dụng với trường dạng String kết hợp với bất kỳ Relational database-based Store. PostGIS DataStore với các hàm encode được kích hoạt hoặc bất kỳ image mosaic nào có được index trong Relational Database là 1 trong những trường hợp tồn tại lỗ hổng.
- `strEndsWith`function: Lỗ hổng này phát sinh khi chức năng strEndsWith được sử dụng với PostGIS DataStore có sử dụng hàm encode.
- `strStartsWith` function: Tương tự với `strEndsWith`.
- `FeatureId` filter: Lỗ hổng này xuất hiện FeatureId filter được sử dụng với bất kỳ bảng cơ sở dữ liệu nào có khóa chính ở dạng String cùng điều kiện Prepared Statement không được sử dụng.
- `jsonArrayContains` function: Lỗ hổng này được tìm thấy khi hàm jsonArrayContains được sử dụng với trường dạng String hoặc JSON và với PostGIS DataStore hoặc Oracle (chỉ trong GeoServer 2.22.0 và các phiên bản mới hơn).
- `DWithin` filter: Lỗ hổng này được phát hiện khi DWithin filter được sử dụng với Oracle DataStore.

## Các phiên bản tồn tại lỗ hổng CVE-2023-25157

GeoServer: < 2.21.4, >= 2.22.0, < 2.22.2.
Các bản vá đã được ra mắt, tham khảo tại: https://github.com/geoserver/geoserver/releases.

## Chuẩn bị môi trường debug

- PostgreSQL và PostGIS: 2 cái này search Google rồi cài theo hướng dẫn.
- GeoServer source: Ở đây mình dùng phiên bản GeoServer 2.22.1. Download tại đây: https://github.com/geoserver/geoserver/archive/refs/tags/2.22.1.zip
- IDE: IntelliJ (bản Community hay Ultimate đều được).
- Sau khi cài xong các mục trên, setup project để chạy được trên IntelliJ theo link https://docs.geoserver.org/latest/en/developer/quickstart/intellij.html
- Sau đó thêm sample data vào theo link https://docs.geoserver.org/latest/en/user/gettingstarted/postgis-quickstart/index.html

##  Phân tích lỗ hổng

Setup môi trường như mục bên trên, chạy debug trong IntelliJ. Mặc định GeoServer sẽ chạy ở port 8080. 
Để khai thác lỗ hổng này, trước tiên cần phải có 2 thông tin:

- Tên Feature đang có trong Database.
- Properties cho mỗi Feature tương ứng.

Gửi request sau đến GeoServer để lấy được tên Feature có sẵn:
```
GET /geoserver/ows?service=WFS&version=1.0.0&request=GetCapabilities HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
```
Response:

![enter image description here](https://imgur.com/KsY8GUV.png)

Theo response trên, lấy được Feature name là `nyc:nyc_buildings`.

Request để lấy Feature Properties:

```
GET /geoserver/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings&maxFeatures=1&outputFormat=json HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Các bạn thay `nyc:nyc_buildings` ở URL bằng Feature Name lấy được ở request trước.
Response:

![enter image description here](https://imgur.com/L1FlE7h.png)

Theo response trên, lấy được Feature Properties là `bin`.

Sau khi có đủ 2 trường cần thiết là Feature Name và Feature Properties, ta đã có thể khai thác lỗ hổng SQLi trên GeoServer.
 
 Trước khi đi vào debug, dưới đây là một số tổ hợp phím tắt trong IntelliJ để tiết kiệm thời gian:
 
 - Shift + Shift = tìm file theo tên.
 - Ctrl + F12 = tìm Method trong file.
 - Ctrl + Shift + F = tìm text từ mọi nơi.
 - F8 = Step Over - Nhảy đến dòng tiếp theo trong debug.
 - F9 = Resume Program - Bỏ qua các bước tiếp theo trong debug, return luôn cho client.
 - F7 = Step into - Nhảy vào method được thực thi trong luồng code đang chạy.
 - Shift + F8 = Step out - Ngược lại với step into, nhảy ra khỏi method đang được debug.


Ở đây mình chọn `strStartsWith` để phân tích về lỗ hổng.

Đầu tiên, đặt breakpoint vào phương thức getAggregateValue trong org.geotools.jdbc.JDBCDataSource.java. Gửi request như sau:

```
GET /geoserver/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=nyc:nyc_buildings=strStartsWith%28bin%2C%27x%27%27%29+%3D+true+and+1%3D%28SELECT+CAST+%28%28SELECT+version()%29+AS+INTEGER%29%29+--+%27%29+%3D+true HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate
Connection: close
```

Sau khi gửi request, debugger nhảy đến breakpoint được đặt, nhấn F8 cho đến phần sau đây của phương thức:

![enter image description here](https://imgur.com/yTOTbdP.png)

Về cơ bản, phương thức getAggregateValue thực hiện kiểm tra SQL dialect, tạo gọi đến các phương thức khác để tạo câu lệnh SQL tương ứng, thực thi bằng executeQuery và return kết quả hoặc throw nếu xảy ra Exception.

Nhấn F7 để nhảy vào phương thức selectAggregateSQL.

![enter image description here](https://imgur.com/jnsfGNa.png)

Ở đây gọi đến phương thức doSelectAggregateSQL, tiếp tục F7 để nhảy vào phương thức này.

F8 cho tới khi đến đoạn dưới đây:

![enter image description here](https://imgur.com/mPZuXoA.png)

Phương thức doSelectAggregateSQL có chức năng chính là để tạo ra câu lệnh SQL hoàn chỉnh.
Trong phương thức doSelectAggregateSQL, biến sql được append `SELECT `-> được xử lý bởi phương thức encodeFunction để append ` count(*) `-> được append ` FROM `-> được xử lý bởi phương thức encodeTableName để append `"public"."nyc_buildings"`-> append `WHERE`.

Tới đây, câu SQL có dạng:

`SELECT count(*) FROM "public"."nyc_buildings WHERE "`.

![enter image description here](https://imgur.com/xWjvJ7t.png)

Tại đây gọi đến phương thức filter để xử lý và append điều kiện vào sau "WHERE".

F7 để nhảy vào phương thức filter.

![enter image description here](https://imgur.com/CkNBsOm.png)

Tại đây gọi vào 1 phương thức filter khác. Tiếp tục F7.

![enter image description here](https://imgur.com/Ug1RW6Y.png)

Ở đây thực hiện encode Filter sang String và append trực tiếp vào phần điều kiện phía sau WHERE của biến sql. 
Tới đây, câu SQL có dạng:

```
SELECT count(*) FROM "public"."nyc_buildings" WHERE ("bin"::text LIKE 'x') = true and 1=(SELECT CAST ((SELECT version()) AS INTEGER)) -- %') = true
```

![enter image description here](https://imgur.com/DPKUNGK.png)

F8 cho đến khi nhảy ra phương thức getAggregateValue. Tại đây, câu SQL đã được hoàn thiện để thực hiện query xuống DB.

![enter image description here](https://imgur.com/8W5QkbB.png)

Câu lệnh SQL sau đó được thực thi bởi executeQuery và throw ra SQLException do không đoạn `SELECT CAST ((SELECT version()) AS INTEGER)`. Và Exception được trả ra output.

Response chứa thông tin về DB version:

![enter image description here](https://imgur.com/jKAK1l9.png)

Tóm tắt code flow:

![enter image description here](https://imgur.com/OguuQrE.png)

## Vá lỗ hổng

-   [GEOS-10842: JDBCConfig: escape user inputs in SQL queries](https://osgeo-org.atlassian.net/browse/GEOS-10842)
-   [GEOS-10839: JDBCConfig: add JDBC Configuration parameter to disable SQL comments and pretty-printing](https://osgeo-org.atlassian.net/browse/GEOS-10839)
-   [GEOT-7302: Escape user inputs in SQL queries](https://osgeo-org.atlassian.net/browse/GEOT-7302)

Tóm tắt các thay đổi:

- Query theo dạng PreparedStatement thay cho cộng chuỗi trực tiếp.
- SQL Comment Escaping: Escape các ký tự comment trong SQL.
- Append các chuỗi vào SQL theo điều kiện: Phương thức appendIfDebug đã được thêm vào lớp Dialect. Phương thức này append thêm một trong hai chuỗi được cung cấp vào SQL tùy thuộc vào việc chế độ debug có được bật hay không. Trong lớp Dialect.java, một trường debugMode được thêm vào và một phương thức setDebugMode() được cung cấp để thay đổi trạng thái của nó. Chế độ debug sau đó được sử dụng trong phương thức detect().
- Backslash, DoubleQuote Escaping.
- Sử dụng `writeLiteral()` thay cho `out.write()` để kiểm soát output một cách tốt hơn, giảm thiểu thông tin trả ra trong trường hợp vẫn bị khai thác SQLi.

## Nguồn tham khảo

https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158

https://github.com/win3zz/CVE-2023-25157
